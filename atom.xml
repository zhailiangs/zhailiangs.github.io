<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhailiangs&#39;blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-03-23T06:35:22.797Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zhailiangs</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python3.8.6安装时提示Detected Windows 7 SP1 without KB2533623</title>
    <link href="http://yoursite.com/2021/03/23/python-install-erro/"/>
    <id>http://yoursite.com/2021/03/23/python-install-erro/</id>
    <published>2021-03-23T06:33:00.670Z</published>
    <updated>2021-03-23T06:35:22.797Z</updated>
    
    <content type="html"><![CDATA[<p>下载的安装包，双击安装时，提示安装失败，经过界面中的提示，打开日志后，最后一行提示：Detected Windows 7 SP1 without KB2533623<br>解决办法：<br>需要更新安装win7系统的KB2533623，我的是64位操作系统<br>下载地址：<a href="https://zhailiangs.github.io/download/Windows6.1--KB2533623-x64.msu" target="_blank" rel="noopener">https://zhailiangs.github.io/download/Windows6.1--KB2533623-x64.msu</a><br>百度网盘：<br>链接: <a href="https://pan.baidu.com/s/1bDNwJCjo9DDSANOPsU1ztA" target="_blank" rel="noopener">https://pan.baidu.com/s/1bDNwJCjo9DDSANOPsU1ztA</a> 提取码: wdqs 复制这段内容后打开百度网盘手机App，操作更方便哦<br>下载完成后，安装重启电脑即可。<br>————————————————<br>版权声明：本文为CSDN博主「雪诺颜」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/lxiaoqqin/article/details/106402866" target="_blank" rel="noopener">https://blog.csdn.net/lxiaoqqin/article/details/106402866</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下载的安装包，双击安装时，提示安装失败，经过界面中的提示，打开日志后，最后一行提示：Detected Windows 7 SP1 without KB2533623&lt;br&gt;解决办法：&lt;br&gt;需要更新安装win7系统的KB2533623，我的是64位操作系统&lt;br&gt;下载地址：
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>给python的pip设置代理</title>
    <link href="http://yoursite.com/2021/03/23/python-pip-proxy/"/>
    <id>http://yoursite.com/2021/03/23/python-pip-proxy/</id>
    <published>2021-03-23T06:29:45.488Z</published>
    <updated>2021-03-23T06:31:17.206Z</updated>
    
    <content type="html"><![CDATA[<p>由于网络原因，访问国外的pip源超级慢，因此可以给pip设置代理或设置国内源提高速度</p><ul><li>Windows：</li></ul><ol><li>进入%APPDATA%目录，例如：C:\Users\用户名\AppData\Roaming</li><li>新建pip文件夹，如果有则跳过</li><li>新建pip.ini文件，设置pip源<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">proxy=http://127.0.0.1:1081</span><br></pre></td></tr></table></figure></li></ol><ul><li>Linux：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.pip/pip.conf</span><br></pre></td></tr></table></figure><p>用vi编辑pip.conf文件，内容与Windows下pip.ini文件的内容一样</p><p>原文链接:<a href="https://blog.csdn.net/weixin_42191996/article/details/102332805" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42191996/article/details/102332805</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于网络原因，访问国外的pip源超级慢，因此可以给pip设置代理或设置国内源提高速度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Windows：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;进入%APPDATA%目录，例如：C:\Users\用户名\AppData\Roaming&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="pip" scheme="http://yoursite.com/tags/pip/"/>
    
  </entry>
  
  <entry>
    <title>同步/异步、并发/并行、线程/进程</title>
    <link href="http://yoursite.com/2020/06/03/async-concurrency-thread/"/>
    <id>http://yoursite.com/2020/06/03/async-concurrency-thread/</id>
    <published>2020-06-03T07:03:24.929Z</published>
    <updated>2020-06-03T07:24:24.372Z</updated>
    
    <content type="html"><![CDATA[<p>看完本文，你将明白以下基本的东西:</p><p>（1）并发（并发只是实现异步的手段之一）并不是没有阻塞的，依然有阻塞，相对的分析，并发依然有阻塞。<br>（2）怎么理解“事件循环”，某个线程一直在各个方法之间永不停歇的游走，遇到一个yield from 就悬挂起来，然后又走到另外一个方法，依次进行下去，知道事件循环所有的方法执行完毕。<br>（3）并发（异步）一定会比同步快吗？当然不是了，参见后面文章的实验。<br>（4）并发分为真并发、伪并发，并发与并行的区别在于“是否同时”<br>（5）异步是最终的目的，并发和并行都可以实现异步，线程是决定了是使用并发还是并行的手段。<br>（6）最好的实现方式当然是并行了，</p><p>首先介绍一些最基本的概念和核心思想。</p><h2 id="一、进程、线程"><a href="#一、进程、线程" class="headerlink" title="一、进程、线程"></a>一、进程、线程</h2><ol><li>进程（Process）:</li></ol><p>是Windows系统中的一个基本概念，它包含着一个运行程序所需要的资源。一个正在运行的应用程序在操作系统中被视为一个进程，进程可以包括一个或多个线程。线程是操作系统分配处理器时间的基本单元，在进程中可以有多个线程同时执行代码。进程之间是相对独立的，一个进程无法访问另一个进程的数据（除非利用分布式计算方式），一个进程运行的失败也不会影响其他进程的运行，Windows系统就是利用进程把工作划分为多个独立的区域的。进程可以理解为一个程序的基本边界。是应用程序的一个运行例程，是应用程序的一次动态执行过程。</p><ol start="2"><li>线程（Thread）:</li></ol><p>是进程中的基本执行单元，是操作系统分配CPU时间的基本单位，一个进程可以包含若干个线程，在进程入口执行的第一个线程被视为这个进程的主线程。在.NET应用程序中，都是以Main()方法作为入口的，当调用此方法时系统就会自动创建一个主线程。线程主要是由CPU寄存器、调用栈和线程本地存储器（Thread Local Storage，TLS）组成的。CPU寄存器主要记录当前所执行线程的状态，调用栈主要用于维护线程所调用到的内存与数据，TLS主要用于存放线程的状态信息。</p><p>线程的本质:线程不是一个计算机硬件的功能，而是操作系统提供的一种逻辑功能，线程本质上是进程中一段并发运行的代码，所以线程需要操作系统投入CPU资源来运行和调度。</p><ol start="3"><li>进程和线程的区别</li></ol><p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p><p> 1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.</p><p> 2) 线程的划分尺度小于进程，使得多线程程序的并发性高。</p><p> 3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p><p> 4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p><p> 5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p><h2 id="二、-同步（Sync）和异步（Async）"><a href="#二、-同步（Sync）和异步（Async）" class="headerlink" title="二、 同步（Sync）和异步（Async）"></a>二、 同步（Sync）和异步（Async）</h2><ol><li>同步:</li></ol><p>所谓同步，就是发出一个功能调用时，在没有得到结果之前，该调用就不返回或继续执行后续操作。</p><p>简单来说，同步就是必须一件一件事做，等前一件做完了才能做下一件事。</p><ol start="2"><li>异步:</li></ol><p>异步与同步相对，当一个异步过程调用发出后，调用者在没有得到结果之前，就可以继续执行后续操作。当这个调用完成后，一般通过状态、通知和回调来通知调用者。对于异步调用，调用的返回并不受调用者控制。</p><p>对于通知调用者的三种方式，具体如下:</p><p>状态</p><p>即监听被调用者的状态（轮询），调用者需要每隔一定时间检查一次，效率会很低。</p><p>通知</p><p>当被调用者执行完成后，发出通知告知调用者，无需消耗太多性能。</p><p>回调</p><p>与通知类似，当被调用者执行完成后，会调用调用者提供的回调函数。</p><ol start="3"><li>同步和异步的区别:</li></ol><p>总结来说，同步和异步的区别:请求发出后，是否需要等待结果，才能继续执行其他操作。</p><h2 id="三、阻塞和非阻塞"><a href="#三、阻塞和非阻塞" class="headerlink" title="三、阻塞和非阻塞"></a>三、阻塞和非阻塞</h2><p>阻塞和非阻塞这两个概念仅仅与等待消息通知时的状态有关。跟同步、异步没什么太大关系，也就是说阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的。</p><p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.</p><p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。</p><p>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p><p>总结:同步执行一般都会有阻塞，但也有可能没阻塞；异步执行也有可能有阻塞，也可能没有阻塞。后面会讲到。</p><h2 id="四、并发并行"><a href="#四、并发并行" class="headerlink" title="四、并发并行"></a>四、并发并行</h2><p>并发:在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程，它只能把CPU运行时间划分成若干个时间段,再将时间 段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状态。.这种方式我们称之为并发(Concurrent)。</p><p>并行:当系统有一个以上CPU时,则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)</p><p>并发和并行的区别:</p><p>（1）你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。因为在完成吃饭这件事情之前，打电话这件事你是完全没开始的，是一个一个来的）</p><p>（2）你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。因为吃饭和电话两件事情都处于启动状态，而不是一件事做完才启动另一件事，但是虽然几件事情都开始了，但因为是一个线程，还是一个一个交替去做的，这也是python协程的思想。</p><p>（3）你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。因为这是同时在进行多件事情，而不是交替执行。</p><p>怎么区别呢？区分它们最关键的点就是:是否是『同时』。</p><p>并发的关键是你有处理多个任务的能力，不一定要同时；但是并行的关键是你有同时处理多个任务的能力。</p><h2 id="五、关键概念的区分"><a href="#五、关键概念的区分" class="headerlink" title="五、关键概念的区分"></a>五、关键概念的区分</h2><ol><li><p>阻塞/非阻塞:关注的是程序在等待调用结果（消息，返回值）时的状态</p></li><li><p>同步/异步:关注的是消息通知的机制。即等到完全做完才通知，还是你先做你的，我先做我的 ，你做完了再来通知我就可以了。</p></li></ol><p>所谓同步，就是在发出一个*调用*时，在没有得到结果之前，该*调用*就不返回。但是一旦调用返回，就得到返回值了。<br>换句话说，就是由*调用者*主动等待这个*调用*的结果。</p><p>而异步则是相反，*调用*在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在*调用*发出后，*被调用者*通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p><p>上面的两组概念是可以两两搭配的，即</p><ol start="3"><li>同步阻塞、同步非阻塞，异步阻塞、异步非阻塞。</li></ol><p>举个简单的例子来描述这四种情况，老张要做两件事，用水壶烧开水，看电视，两件事情即两个任务，两个函数。<br>同步阻塞:老张把水壶放到火上，就坐在那里等水开，开了之后我再去看电视。（同步阻塞）</p><p>同步非阻塞:老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）</p><p>老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀的噪音。</p><p>异步阻塞:老张把响水壶放到火上，然后就坐在旁边等着听那个烧开的提示音。（异步阻塞）</p><p>异步非阻塞:老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）</p><p>乍一看，这“同步阻塞、意不阻塞”似乎没有什么区别，但实际上是有区别的，所谓同步异步，指的是消息通知的机制。区别在哪里呢？</p><p>在这个例子中同步异步只是对于水壶而言。在使用普通水壶的时候，我要自己主动去观察水是不是烧开了，自己主动去获取烧开的这个结果，即所谓的同步；但是在响水壶的时候，我不需要再管水烧到什么程度了，因为只要水烧开了，那个滴滴的噪声就会通知我的，即所谓的异步。</p><p>他们的相同点是，在烧水的过程中，老王啥也没干，即“阻塞”。</p><ol start="4"><li>四种总结——同步/异步与阻塞/非阻塞</li></ol><p>同步阻塞形式:效率是最低的。拿上面的例子来说，在烧水的过程中，什么别的事都不做。</p><p>同步非阻塞形式:实际上是效率低下的。因为老王需要不断的在看电视与烧水之间来回跑动，看一下电视，又要去看一下水烧开没有，这样来回跑很多次，在程序中，程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的。</p><p>异步阻塞形式:异步操作是可以被阻塞住的，只不过它不是在处理消息时阻塞，而是在等待消息通知时被阻塞。这个效率其实跟同步阻塞差不多的。</p><p>异步非阻塞形式:效率更高。因为老王把水烧好之后就不用管了，可以安安心心去看电视，不用来回奔波看水烧开了没，因为水烧开了会有提示告诉他水烧好了，这样效率岂不是更高。</p><p>那有没有更好的办法？当然有，如果老王还有一个帮手老张，让老王自己看电视、同时老张去烧开水，这样岂不是更好？这就是所谓的并行。</p><ol start="5"><li>并发/并行、同步/异步、阻塞/非阻塞</li></ol><p>并发/并行:即能够开启多个任务，多个任务交替执行为并发，多个任务同时执行为并行</p><p>同步/异步:关注的是消息通知的机制，主动等候消息则为同步、被动听消息则为异步</p><p>阻塞/非阻塞:关注的是等候消息的过程中有没有干其他事。</p><p>总结:上面的几组概念，时刻穿插的，并没有完全的等价关系，所以经常有人说，异步就是非阻塞，同步就是阻塞，并发就是非阻塞、并行就是非阻塞，这些说法都是不完全准确地。</p><h2 id="六、最终结论概括"><a href="#六、最终结论概括" class="headerlink" title="六、最终结论概括"></a>六、最终结论概括</h2><p>并发和并行都是实现异步编程的思路，只有一个线程的并发，称之为“伪并发”；有多个线程的并发称之为“真并发”，真并发与并行是很接近的。</p><ol><li>异步操作的优缺点</li></ol><p>因为异步操作无须额外的线程负担（这里指的是单线程交替执行的“伪并发”），并且使用回调的方式进行处理，在设计良好的情况下，处理函数可以不必使用共享变量（即使无法完全不用，最起码可以减少共享变量的数量），减少了死锁的可能。当然异步操作也并非完美无暇。编写异步操作的复杂程度较高，程序主要使用回调方式进行处理，与普通人的思维方式有些 初入，而且难以调试。</p><ol start="2"><li>多线程的优缺点</li></ol><p>多线程的优点很明显，线程中的处理程序依然是顺序执行，符合普通人的思维习惯，所以编程简单。但是多线程的缺点也同样明显，线程的使用（滥用）会给系统带来上下文切换的额外负担。并且线程间的共享变量可能造成死锁的出现。</p><p>异步与多线程,从辩证关系上来看,异步和多线程并不时一个同等关系,（因为单线程也是可以实现异步的）异步是目的,多线程只是我们实现异步的一个手段.什么是异步:异步是当一个调用请求发送给被调用者,而调用者不用等待其结果的返回.实现异步可以采用多线程技术或则交给另外的进程来处理<br>————————————————<br>版权声明:本文为CSDN博主「LoveMIss-Y」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接:<a href="https://blog.csdn.net/qq_27825451/article/details/86162597" target="_blank" rel="noopener">https://blog.csdn.net/qq_27825451/article/details/86162597</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看完本文，你将明白以下基本的东西:&lt;/p&gt;
&lt;p&gt;（1）并发（并发只是实现异步的手段之一）并不是没有阻塞的，依然有阻塞，相对的分析，并发依然有阻塞。&lt;br&gt;（2）怎么理解“事件循环”，某个线程一直在各个方法之间永不停歇的游走，遇到一个yield from 就悬挂起来，然后又
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="协程" scheme="http://yoursite.com/tags/%E5%8D%8F%E7%A8%8B/"/>
    
      <category term="异步" scheme="http://yoursite.com/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>利用Tor网络实现自动切换IP的爬虫</title>
    <link href="http://yoursite.com/2020/04/24/tor-spider/"/>
    <id>http://yoursite.com/2020/04/24/tor-spider/</id>
    <published>2020-04-24T08:45:06.696Z</published>
    <updated>2021-01-16T01:28:07.779Z</updated>
    
    <content type="html"><![CDATA[<p>当从网络上采集数据时经常会遇到IP被限制的情况，需要不停的更换IP。Tor拥有庞大的IP池，可以帮助我们实现IP切换。如果你的爬虫程序在linux环境下运行请参考<a href="https://zhuanlan.zhihu.com/p/24261906" target="_blank" rel="noopener">《基于Tor网络的多ip爬虫》</a>,下面只介绍windows环境下如何使用。</p><h2 id="安装-Tor-Browser"><a href="#安装-Tor-Browser" class="headerlink" title="安装 Tor Browser"></a>安装 Tor Browser</h2><p>下载地址：<a href="https://www.torproject.org/download/" target="_blank" rel="noopener">https://www.torproject.org/download/</a></p><p>安装过程中记住 Tor Browser 的安装路径，安装完成后找到tor.exe的位置，例如：D:\Browser\TorBrowser\Tor\tor.exe</p><h2 id="下载-Vidalia"><a href="#下载-Vidalia" class="headerlink" title="下载 Vidalia"></a>下载 Vidalia</h2><p>Vidalia的下载地址：<a href="https://people.torproject.org/~erinn/vidalia-standalone-bundles/" target="_blank" rel="noopener">https://people.torproject.org/~erinn/vidalia-standalone-bundles/</a> 下载该页面的最下面那个即可：vidalia-standalone-0.2.21-win32-1_zh-CN.exe，安装完成之后，以管理员权限运行Start Vidalia.exe，进行下面的设定：</p><p><img src="/images/tor-spider-1.png" alt="点击显示设定" title="点击显示设定"><br><img src="/images/tor-spider-2.png" alt="填写tor.exe的路径" title="填写tor.exe的路径"><br><img src="/images/tor-spider-3.png" alt="设置本地代理" title="设置本地代理"><br><img src="/images/tor-spider-4.png" alt="点击启动Tor" title="点击启动Tor"></p><p>如果你的爬虫程序支持设置socks5代理，把代理IP设置为127.0.0.1 端口设置为9050 就可以了<br>如果你的爬虫程序仅支持HTTP代理，则还需要进行下面的操作安装Polipo，将socks5代理转换为HTTP代理</p><h2 id="下载安装Polipo"><a href="#下载安装Polipo" class="headerlink" title="下载安装Polipo"></a>下载安装Polipo</h2><p>下载地址：<a href="http://www.pps.univ-paris-diderot.fr/~jch/software/files/polipo/" target="_blank" rel="noopener">http://www.pps.univ-paris-diderot.fr/~jch/software/files/polipo/</a></p><p>选择polipo-1.1.0-win32.zip，下载并解压，然后编辑解压后的文件config.sample，在文件的开头加上以下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">socksParentProxy = &quot;localhost:9050&quot;</span><br><span class="line"></span><br><span class="line">socksProxyType = socks5</span><br><span class="line"></span><br><span class="line">diskCacheRoot = &quot;&quot;</span><br></pre></td></tr></table></figure></p><p>使用cmd命令运行该目录下的程序：polipo.exe -c config.sample</p><p><img src="/images/tor-spider-5.png" alt="使用cmd命令运行该目录下的程序" title="使用cmd命令运行该目录下的程序"></p><p>转换后的HTTP代理为127.0.0.1:8123</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol><li>长时间无法连接Tor：<ul><li>检查用来连接Tor的代理是否可用</li><li>如果使用V2ray来连接Tor, 需要在V2ray的配置中关闭流量探测<br><img src="/images/tor-spider-6.png" alt="不要勾选开启流量探测" title="不要勾选开启流量探测"></li></ul></li><li>待补充</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当从网络上采集数据时经常会遇到IP被限制的情况，需要不停的更换IP。Tor拥有庞大的IP池，可以帮助我们实现IP切换。如果你的爬虫程序在linux环境下运行请参考&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24261906&quot; target=&quot;
      
    
    </summary>
    
      <category term="爬虫" scheme="http://yoursite.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Tor" scheme="http://yoursite.com/tags/Tor/"/>
    
  </entry>
  
  <entry>
    <title>Hexo文章加密</title>
    <link href="http://yoursite.com/2020/04/16/article-password/"/>
    <id>http://yoursite.com/2020/04/16/article-password/</id>
    <published>2020-04-16T08:11:56.006Z</published>
    <updated>2020-04-16T08:17:24.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件,在以下位置插入这样一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    (function()&#123;</span><br><span class="line">        if(&apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123;</span><br><span class="line">            if (prompt(&apos;请输入文章密码&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123;</span><br><span class="line">                alert(&apos;密码错误！&apos;);</span><br><span class="line">                history.back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;打开themes-&amp;gt;next-&amp;gt;layout-&amp;gt;_partials-&amp;gt;head.swig文件,在以下位置插入这样一段
      
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>APScheduler中BlockingScheduler和BackgroundScheduler的区别</title>
    <link href="http://yoursite.com/2018/05/18/apscheduler-backgroundscheduler/"/>
    <id>http://yoursite.com/2018/05/18/apscheduler-backgroundscheduler/</id>
    <published>2018-05-18T10:07:53.000Z</published>
    <updated>2018-05-21T02:34:24.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>APScheduler是基于Quartz的一个Python定时任务框架，提供了基于日期、固定时间间隔以及crontab类型的任务，并且可以持久化任务。</p><p>这里简单列一下常用的若干调度器：</p><p>BlockingScheduler：仅可用在当前你的进程之内，与当前的进行共享计算资源<br>BackgroundScheduler:　在后台运行调度，不影响当前的系统计算运行<br>AsyncIOScheduler:　如果当前系统中使用了async module，则需要使用异步的调度器<br>GeventScheduler:　如果使用了gevent，则需要使用该调度<br>TornadoScheduler:　如果使用了Tornado, 则使用当前的调度器<br>TwistedScheduler:Twister应用的调度器<br>QtScheduler:　Qt的调度器</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>我在使用APScheduler过程中想使用BackgroundScheduler调度器，结果任务一直无法执行，后来换用BlockingScheduler，结果可以正常执行。</p><p>BackgroundScheduler调度器代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line">from datetime import datetime</span><br><span class="line">from apscheduler.schedulers.background import BackgroundScheduler</span><br><span class="line">from apscheduler.jobstores.sqlalchemy import SQLAlchemyJobStore</span><br><span class="line">from apscheduler.executors.pool import ThreadPoolExecutor, ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line">def test(text):</span><br><span class="line">    date1 = datetime.now().strftime(&apos;%Y-%m-%d %H:%M:%S&apos;)</span><br><span class="line">    f = open(&apos;log2.txt&apos;,&apos;a&apos;)</span><br><span class="line">    f.write(date1 + &apos;-&apos; * 10 + text + &apos;-&apos; * 10 + &apos;\n&apos;)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line">jobstores = &#123;</span><br><span class="line">    &apos;default&apos;: SQLAlchemyJobStore(url=&apos;sqlite:///jobs.sqlite&apos;)</span><br><span class="line">&#125;</span><br><span class="line">executors = &#123;</span><br><span class="line">    &apos;default&apos;: ThreadPoolExecutor(20),</span><br><span class="line">    &apos;processpool&apos;: ProcessPoolExecutor(5)</span><br><span class="line">&#125;</span><br><span class="line">job_defaults = &#123;</span><br><span class="line">    &apos;coalesce&apos;: False,</span><br><span class="line">    &apos;max_instances&apos;: 3</span><br><span class="line">&#125;</span><br><span class="line">scheduler = BackgroundScheduler(jobstores=jobstores, executors=executors, job_defaults=job_defaults, timezone=&apos;Asia/Shanghai&apos;)</span><br><span class="line">scheduler.start()</span><br><span class="line">scheduler.add_job(test,&apos;date&apos;,run_date=&apos;2018-05-18 16:56:01&apos;,args=[&apos;my_test3&apos;],id=&apos;my_test4&apos;)</span><br></pre></td></tr></table></figure><p>BlockingScheduler调度器代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line">import datetime</span><br><span class="line">from apscheduler.schedulers.blocking import BlockingScheduler</span><br><span class="line">from apscheduler.jobstores.sqlalchemy import SQLAlchemyJobStore</span><br><span class="line">from apscheduler.executors.pool import ThreadPoolExecutor, ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"># 使用sqlite存储作业</span><br><span class="line">sqlitedb = r&quot;sqlitedb.db&quot;</span><br><span class="line">url = r&apos;sqlite:///%s&apos; %sqlitedb</span><br><span class="line"></span><br><span class="line">def test(text):</span><br><span class="line">    print(datetime.datetime.now())</span><br><span class="line">    print(&apos;-&apos; * 10 + text + &apos;-&apos; * 10)</span><br><span class="line"></span><br><span class="line">jobstores = &#123;</span><br><span class="line">    &apos;default&apos;: SQLAlchemyJobStore(url=url)</span><br><span class="line">&#125;</span><br><span class="line">executors = &#123;</span><br><span class="line">    &apos;default&apos;: ThreadPoolExecutor(20),</span><br><span class="line">    &apos;processpool&apos;: ProcessPoolExecutor(5)</span><br><span class="line">&#125;</span><br><span class="line">job_defaults = &#123;</span><br><span class="line">    &apos;coalesce&apos;: False,</span><br><span class="line">    &apos;max_instances&apos;: 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sched = BlockingScheduler(jobstores=jobstores, executors=executors, job_defaults=job_defaults)</span><br><span class="line">sched.add_job(test,next_run_time= args=[&apos;my_test&apos;],id=&apos;my_test&apos;)</span><br><span class="line">sched.start()</span><br></pre></td></tr></table></figure><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>BackgroundScheduler调度器依赖于python脚本的主进程，如果主进程不存在定时任务也就不存在，我的代码里面没有可以维持脚本运行的主进程所以无法执行定时任务</p><h2 id="正确示例代码"><a href="#正确示例代码" class="headerlink" title="正确示例代码"></a>正确示例代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># coding=utf-8</span><br><span class="line">from datetime import datetime</span><br><span class="line">import time</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">from apscheduler.schedulers.background import BackgroundScheduler</span><br><span class="line">from apscheduler.jobstores.sqlalchemy import SQLAlchemyJobStore</span><br><span class="line">from apscheduler.executors.pool import ThreadPoolExecutor, ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line">def test(text):</span><br><span class="line">    date1 = datetime.now().strftime(&apos;%Y-%m-%d %H:%M:%S&apos;)</span><br><span class="line">    f = open(&apos;log2.txt&apos;,&apos;a&apos;)</span><br><span class="line">    f.write(date1 + &apos;-&apos; * 10 + text + &apos;-&apos; * 10 + &apos;\n&apos;)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    jobstores = &#123;</span><br><span class="line">    &apos;default&apos;: SQLAlchemyJobStore(url=&apos;sqlite:///jobs.sqlite&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    executors = &#123;</span><br><span class="line">        &apos;default&apos;: ThreadPoolExecutor(20),</span><br><span class="line">        &apos;processpool&apos;: ProcessPoolExecutor(5)</span><br><span class="line">    &#125;</span><br><span class="line">    job_defaults = &#123;</span><br><span class="line">        &apos;coalesce&apos;: False,</span><br><span class="line">        &apos;max_instances&apos;: 3</span><br><span class="line">    &#125;</span><br><span class="line">    scheduler = BackgroundScheduler(jobstores=jobstores, executors=executors, job_defaults=job_defaults, timezone=&apos;Asia/Shanghai&apos;)</span><br><span class="line">    #scheduler.add_job(tick, &apos;interval&apos;, seconds=3)</span><br><span class="line">    scheduler.add_job(test,&apos;date&apos;,run_date=&apos;2018-05-18 17:12:01&apos;, args=[&apos;my_test5&apos;],id=&apos;my_test5&apos;)</span><br><span class="line">    scheduler.start()  #这里的调度任务是独立的一个线程</span><br><span class="line">    print(&apos;Press Ctrl+&#123;0&#125; to exit&apos;.format(&apos;Break&apos; if os.name == &apos;nt&apos; else &apos;C&apos;))</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        # This is here to simulate application activity (which keeps the main thread alive).</span><br><span class="line">        while True:</span><br><span class="line">            time.sleep(2)    #其他任务是独立的线程执行</span><br><span class="line">            print(&apos;sleep!&apos;)</span><br><span class="line">    except (KeyboardInterrupt, SystemExit):</span><br><span class="line">        # Not strictly necessary if daemonic mode is enabled but should be done if possible</span><br><span class="line">        scheduler.shutdown()</span><br><span class="line">        print(&apos;Exit The Job!&apos;)</span><br></pre></td></tr></table></figure><p>参考链接:  </p><p><a href="https://www.cnblogs.com/hushaojun/p/5189109.html" target="_blank" rel="noopener">https://www.cnblogs.com/hushaojun/p/5189109.html</a><br><a href="https://blog.csdn.net/blueheart20/article/details/70219490?locationNum=1&amp;fps=1](https://blog.csdn.net/blueheart20/article/details/70219490?locationNum=1&amp;fps=1)" target="_blank" rel="noopener">https://blog.csdn.net/blueheart20/article/details/70219490?locationNum=1&amp;fps=1](https://blog.csdn.net/blueheart20/article/details/70219490?locationNum=1&amp;fps=1)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;APScheduler是基于Quartz的一个Python定时任务框架，提供了基于日期、固定时间间隔以及crontab类型的任务，并且可以持
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="APScheduler" scheme="http://yoursite.com/tags/APScheduler/"/>
    
  </entry>
  
  <entry>
    <title>Centos显示tcp，udp的端口和进程等相关情况</title>
    <link href="http://yoursite.com/2018/05/18/centos-tcp-udp-show/"/>
    <id>http://yoursite.com/2018/05/18/centos-tcp-udp-show/</id>
    <published>2018-05-18T02:37:57.000Z</published>
    <updated>2018-05-21T02:35:08.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h2><p>netstat命令是一个监控TCP/IP网络的非常有用的工具，它可以显示路由表、实际的网络连接以及每一个网络接口设备<br>netstat命令的功能是显示网络连接、路由表和网络接口信息，可以让用户得知目前都有哪些网络连接正在运作。<br>该命令的一般格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">netstat [选项]</span><br><span class="line">    命令中各选项的含义如下：</span><br><span class="line">    -a 显示所有socket，包括正在监听的。</span><br><span class="line">    -c 每隔1秒就重新显示一遍，直到用户中断它。</span><br><span class="line">    -i 显示所有网络接口的信息，格式同“ifconfig -e”。</span><br><span class="line">    -n 以网络IP地址代替名称，显示出网络连接情形。</span><br><span class="line">    -r 显示核心路由表，格式同“route -e”。</span><br><span class="line">    -t 显示TCP协议的连接情况。</span><br><span class="line">    -u 显示UDP协议的连接情况。</span><br><span class="line">    -v 显示正在进行的工作。</span><br></pre></td></tr></table></figure><h2 id="netstat-tunlp"><a href="#netstat-tunlp" class="headerlink" title="netstat -tunlp"></a>netstat -tunlp</h2><p>用于显示tcp，udp的端口和进程等相关情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tunlp</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;netstat命令&quot;&gt;&lt;a href=&quot;#netstat命令&quot; class=&quot;headerlink&quot; title=&quot;netstat命令&quot;&gt;&lt;/a&gt;netstat命令&lt;/h2&gt;&lt;p&gt;netstat命令是一个监控TCP/IP网络的非常有用的工具，它可以显示路由表、实际
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="CentOS" scheme="http://yoursite.com/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>hexo文章属性冒号后面要加空格</title>
    <link href="http://yoursite.com/2018/05/12/article-title/"/>
    <id>http://yoursite.com/2018/05/12/article-title/</id>
    <published>2018-05-12T05:01:31.000Z</published>
    <updated>2018-05-21T02:33:46.339Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>刚开始使用hexo，生成静态文件老是报错，错误提示如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">can not read a block mapping entry; a multiline key may implicit key at line</span><br></pre></td></tr></table></figure></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>冒号后面加空格</p><p>错误写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tags:[hexo入门]</span><br><span class="line">categories:hexo</span><br></pre></td></tr></table></figure></p><p>正确写法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tags: [hexo入门]</span><br><span class="line">categories: hexo</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;刚开始使用hexo，生成静态文件老是报错，错误提示如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table
      
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="hexo入门" scheme="http://yoursite.com/tags/hexo%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/05/12/hello-world/"/>
    <id>http://yoursite.com/2018/05/12/hello-world/</id>
    <published>2018-05-12T04:47:25.320Z</published>
    <updated>2018-05-14T06:20:10.303Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
