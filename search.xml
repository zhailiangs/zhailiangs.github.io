<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python定时任务框架APScheduler中BlockingScheduler和BackgroundScheduler的区别]]></title>
    <url>%2F2018%2F05%2F18%2FPython%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%A1%86%E6%9E%B6APScheduler%E4%B8%ADBlockingScheduler%E5%92%8CBackgroundScheduler%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[背景APScheduler是基于Quartz的一个Python定时任务框架，提供了基于日期、固定时间间隔以及crontab类型的任务，并且可以持久化任务。 这里简单列一下常用的若干调度器： BlockingScheduler：仅可用在当前你的进程之内，与当前的进行共享计算资源BackgroundScheduler: 在后台运行调度，不影响当前的系统计算运行AsyncIOScheduler: 如果当前系统中使用了async module，则需要使用异步的调度器GeventScheduler: 如果使用了gevent，则需要使用该调度TornadoScheduler: 如果使用了Tornado, 则使用当前的调度器TwistedScheduler:Twister应用的调度器QtScheduler: Qt的调度器 遇到的问题我在使用APScheduler过程中想使用BackgroundScheduler调度器，结果任务一直无法执行，后来换用BlockingScheduler，结果可以正常执行。 BackgroundScheduler调度器代码： 123456789101112131415161718192021222324252627#!/usr/bin/python3# -*- coding: UTF-8 -*-from datetime import datetimefrom apscheduler.schedulers.background import BackgroundSchedulerfrom apscheduler.jobstores.sqlalchemy import SQLAlchemyJobStorefrom apscheduler.executors.pool import ThreadPoolExecutor, ProcessPoolExecutordef test(text): date1 = datetime.now().strftime(&apos;%Y-%m-%d %H:%M:%S&apos;) f = open(&apos;log2.txt&apos;,&apos;a&apos;) f.write(date1 + &apos;-&apos; * 10 + text + &apos;-&apos; * 10 + &apos;\n&apos;) f.close()jobstores = &#123; &apos;default&apos;: SQLAlchemyJobStore(url=&apos;sqlite:///jobs.sqlite&apos;)&#125;executors = &#123; &apos;default&apos;: ThreadPoolExecutor(20), &apos;processpool&apos;: ProcessPoolExecutor(5)&#125;job_defaults = &#123; &apos;coalesce&apos;: False, &apos;max_instances&apos;: 3&#125;scheduler = BackgroundScheduler(jobstores=jobstores, executors=executors, job_defaults=job_defaults, timezone=&apos;Asia/Shanghai&apos;)scheduler.start()scheduler.add_job(test,&apos;date&apos;,run_date=&apos;2018-05-18 16:56:01&apos;,args=[&apos;my_test3&apos;],id=&apos;my_test4&apos;) BlockingScheduler调度器代码： 123456789101112131415161718192021222324252627282930#!/usr/bin/python3# -*- coding: UTF-8 -*-import datetimefrom apscheduler.schedulers.blocking import BlockingSchedulerfrom apscheduler.jobstores.sqlalchemy import SQLAlchemyJobStorefrom apscheduler.executors.pool import ThreadPoolExecutor, ProcessPoolExecutor# 使用sqlite存储作业sqlitedb = r&quot;sqlitedb.db&quot;url = r&apos;sqlite:///%s&apos; %sqlitedbdef test(text): print(datetime.datetime.now()) print(&apos;-&apos; * 10 + text + &apos;-&apos; * 10)jobstores = &#123; &apos;default&apos;: SQLAlchemyJobStore(url=url)&#125;executors = &#123; &apos;default&apos;: ThreadPoolExecutor(20), &apos;processpool&apos;: ProcessPoolExecutor(5)&#125;job_defaults = &#123; &apos;coalesce&apos;: False, &apos;max_instances&apos;: 3&#125;sched = BlockingScheduler(jobstores=jobstores, executors=executors, job_defaults=job_defaults)sched.add_job(test,next_run_time= args=[&apos;my_test&apos;],id=&apos;my_test&apos;)sched.start() 原因BackgroundScheduler调度器依赖于python脚本的主进程，如果主进程不存在定时任务也就不存在，我的代码里面没有可以维持脚本运行的主进程所以无法执行定时任务 正确示例代码12345678910111213141516171819202122232425262728293031323334353637383940414243# coding=utf-8from datetime import datetimeimport timeimport osfrom apscheduler.schedulers.background import BackgroundSchedulerfrom apscheduler.jobstores.sqlalchemy import SQLAlchemyJobStorefrom apscheduler.executors.pool import ThreadPoolExecutor, ProcessPoolExecutordef test(text): date1 = datetime.now().strftime(&apos;%Y-%m-%d %H:%M:%S&apos;) f = open(&apos;log2.txt&apos;,&apos;a&apos;) f.write(date1 + &apos;-&apos; * 10 + text + &apos;-&apos; * 10 + &apos;\n&apos;) f.close()if __name__ == &apos;__main__&apos;: jobstores = &#123; &apos;default&apos;: SQLAlchemyJobStore(url=&apos;sqlite:///jobs.sqlite&apos;) &#125; executors = &#123; &apos;default&apos;: ThreadPoolExecutor(20), &apos;processpool&apos;: ProcessPoolExecutor(5) &#125; job_defaults = &#123; &apos;coalesce&apos;: False, &apos;max_instances&apos;: 3 &#125; scheduler = BackgroundScheduler(jobstores=jobstores, executors=executors, job_defaults=job_defaults, timezone=&apos;Asia/Shanghai&apos;) #scheduler.add_job(tick, &apos;interval&apos;, seconds=3) scheduler.add_job(test,&apos;date&apos;,run_date=&apos;2018-05-18 17:12:01&apos;, args=[&apos;my_test5&apos;],id=&apos;my_test5&apos;) scheduler.start() #这里的调度任务是独立的一个线程 print(&apos;Press Ctrl+&#123;0&#125; to exit&apos;.format(&apos;Break&apos; if os.name == &apos;nt&apos; else &apos;C&apos;)) try: # This is here to simulate application activity (which keeps the main thread alive). while True: time.sleep(2) #其他任务是独立的线程执行 print(&apos;sleep!&apos;) except (KeyboardInterrupt, SystemExit): # Not strictly necessary if daemonic mode is enabled but should be done if possible scheduler.shutdown() print(&apos;Exit The Job!&apos;) 参考链接: https://www.cnblogs.com/hushaojun/p/5189109.htmlhttps://blog.csdn.net/blueheart20/article/details/70219490?locationNum=1&amp;fps=1](https://blog.csdn.net/blueheart20/article/details/70219490?locationNum=1&amp;fps=1)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>APScheduler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos显示tcp，udp的端口和进程等相关情况]]></title>
    <url>%2F2018%2F05%2F18%2FCentos%E6%98%BE%E7%A4%BAtcp%EF%BC%8Cudp%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%AD%89%E7%9B%B8%E5%85%B3%E6%83%85%E5%86%B5%2F</url>
    <content type="text"><![CDATA[netstat命令netstat命令是一个监控TCP/IP网络的非常有用的工具，它可以显示路由表、实际的网络连接以及每一个网络接口设备netstat命令的功能是显示网络连接、路由表和网络接口信息，可以让用户得知目前都有哪些网络连接正在运作。该命令的一般格式为： 12345678910netstat [选项] 命令中各选项的含义如下： -a 显示所有socket，包括正在监听的。 -c 每隔1秒就重新显示一遍，直到用户中断它。 -i 显示所有网络接口的信息，格式同“ifconfig -e”。 -n 以网络IP地址代替名称，显示出网络连接情形。 -r 显示核心路由表，格式同“route -e”。 -t 显示TCP协议的连接情况。 -u 显示UDP协议的连接情况。 -v 显示正在进行的工作。 netstat -tunlp用于显示tcp，udp的端口和进程等相关情况1netstat -tunlp]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo文章属性冒号后面要加空格]]></title>
    <url>%2F2018%2F05%2F12%2Farticle-title%2F</url>
    <content type="text"><![CDATA[问题刚开始使用hexo，生成静态文件老是报错，错误提示如下：1can not read a block mapping entry; a multiline key may implicit key at line 解决办法冒号后面加空格 错误写法：12tags:[hexo入门]categories:hexo 正确写法:12tags: [hexo入门]categories: hexo]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
