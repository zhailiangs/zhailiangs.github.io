<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[利用Tor网络实现自动切换IP的爬虫]]></title>
    <url>%2F2020%2F04%2F24%2Ftor-spider%2F</url>
    <content type="text"><![CDATA[当从网络上采集数据时经常会遇到IP被限制的情况，需要不停的更换IP。Tor拥有庞大的IP池，可以帮助我们实现IP切换。如果你的爬虫程序在linux环境下运行请参考《基于Tor网络的多ip爬虫》,下面只介绍windows环境下如何使用。 安装 Tor Browser下载地址：https://www.torproject.org/download/ 安装过程中记住 Tor Browser 的安装路径，安装完成后找到tor.exe的位置，例如：D:\Browser\TorBrowser\Tor\tor.exe 下载 VidaliaVidalia的下载地址：https://people.torproject.org/~erinn/vidalia-standalone-bundles/ 下载该页面的最下面那个即可：vidalia-standalone-0.2.21-win32-1_zh-CN.exe，安装完成之后，以管理员权限运行Start Vidalia.exe，进行下面的设定： 如果你的爬虫程序支持设置socks5代理，把代理IP设置为127.0.0.1 端口设置为9050 就可以了如果你的爬虫程序仅支持HTTP代理，则还需要进行下面的操作安装Polipo，将socks5代理转换为HTTP代理 下载安装Polipo下载地址：http://www.pps.univ-paris-diderot.fr/~jch/software/files/polipo/ 选择polipo-1.1.0-win32.zip，下载并解压，然后编辑解压后的文件config.sample，在文件的开头加上以下配置：12345socksParentProxy = &quot;localhost:9050&quot;socksProxyType = socks5diskCacheRoot = &quot;&quot; 使用cmd命令运行该目录下的程序：polipo.exe -c config.sample 转换后的HTTP代理为127.0.0.1:8123]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Tor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo文章加密]]></title>
    <url>%2F2020%2F04%2F16%2Farticle-password%2F</url>
    <content type="text"><![CDATA[简介打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件,在以下位置插入这样一段代码：12345678910&lt;script&gt; (function()&#123; if(&apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; if (prompt(&apos;请输入文章密码&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; alert(&apos;密码错误！&apos;); history.back(); &#125; &#125; &#125;)();&lt;/script&gt;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APScheduler中BlockingScheduler和BackgroundScheduler的区别]]></title>
    <url>%2F2018%2F05%2F18%2Fapscheduler-backgroundscheduler%2F</url>
    <content type="text"><![CDATA[背景APScheduler是基于Quartz的一个Python定时任务框架，提供了基于日期、固定时间间隔以及crontab类型的任务，并且可以持久化任务。 这里简单列一下常用的若干调度器： BlockingScheduler：仅可用在当前你的进程之内，与当前的进行共享计算资源BackgroundScheduler: 在后台运行调度，不影响当前的系统计算运行AsyncIOScheduler: 如果当前系统中使用了async module，则需要使用异步的调度器GeventScheduler: 如果使用了gevent，则需要使用该调度TornadoScheduler: 如果使用了Tornado, 则使用当前的调度器TwistedScheduler:Twister应用的调度器QtScheduler: Qt的调度器 遇到的问题我在使用APScheduler过程中想使用BackgroundScheduler调度器，结果任务一直无法执行，后来换用BlockingScheduler，结果可以正常执行。 BackgroundScheduler调度器代码： 123456789101112131415161718192021222324252627#!/usr/bin/python3# -*- coding: UTF-8 -*-from datetime import datetimefrom apscheduler.schedulers.background import BackgroundSchedulerfrom apscheduler.jobstores.sqlalchemy import SQLAlchemyJobStorefrom apscheduler.executors.pool import ThreadPoolExecutor, ProcessPoolExecutordef test(text): date1 = datetime.now().strftime(&apos;%Y-%m-%d %H:%M:%S&apos;) f = open(&apos;log2.txt&apos;,&apos;a&apos;) f.write(date1 + &apos;-&apos; * 10 + text + &apos;-&apos; * 10 + &apos;\n&apos;) f.close()jobstores = &#123; &apos;default&apos;: SQLAlchemyJobStore(url=&apos;sqlite:///jobs.sqlite&apos;)&#125;executors = &#123; &apos;default&apos;: ThreadPoolExecutor(20), &apos;processpool&apos;: ProcessPoolExecutor(5)&#125;job_defaults = &#123; &apos;coalesce&apos;: False, &apos;max_instances&apos;: 3&#125;scheduler = BackgroundScheduler(jobstores=jobstores, executors=executors, job_defaults=job_defaults, timezone=&apos;Asia/Shanghai&apos;)scheduler.start()scheduler.add_job(test,&apos;date&apos;,run_date=&apos;2018-05-18 16:56:01&apos;,args=[&apos;my_test3&apos;],id=&apos;my_test4&apos;) BlockingScheduler调度器代码： 123456789101112131415161718192021222324252627282930#!/usr/bin/python3# -*- coding: UTF-8 -*-import datetimefrom apscheduler.schedulers.blocking import BlockingSchedulerfrom apscheduler.jobstores.sqlalchemy import SQLAlchemyJobStorefrom apscheduler.executors.pool import ThreadPoolExecutor, ProcessPoolExecutor# 使用sqlite存储作业sqlitedb = r&quot;sqlitedb.db&quot;url = r&apos;sqlite:///%s&apos; %sqlitedbdef test(text): print(datetime.datetime.now()) print(&apos;-&apos; * 10 + text + &apos;-&apos; * 10)jobstores = &#123; &apos;default&apos;: SQLAlchemyJobStore(url=url)&#125;executors = &#123; &apos;default&apos;: ThreadPoolExecutor(20), &apos;processpool&apos;: ProcessPoolExecutor(5)&#125;job_defaults = &#123; &apos;coalesce&apos;: False, &apos;max_instances&apos;: 3&#125;sched = BlockingScheduler(jobstores=jobstores, executors=executors, job_defaults=job_defaults)sched.add_job(test,next_run_time= args=[&apos;my_test&apos;],id=&apos;my_test&apos;)sched.start() 原因BackgroundScheduler调度器依赖于python脚本的主进程，如果主进程不存在定时任务也就不存在，我的代码里面没有可以维持脚本运行的主进程所以无法执行定时任务 正确示例代码12345678910111213141516171819202122232425262728293031323334353637383940414243# coding=utf-8from datetime import datetimeimport timeimport osfrom apscheduler.schedulers.background import BackgroundSchedulerfrom apscheduler.jobstores.sqlalchemy import SQLAlchemyJobStorefrom apscheduler.executors.pool import ThreadPoolExecutor, ProcessPoolExecutordef test(text): date1 = datetime.now().strftime(&apos;%Y-%m-%d %H:%M:%S&apos;) f = open(&apos;log2.txt&apos;,&apos;a&apos;) f.write(date1 + &apos;-&apos; * 10 + text + &apos;-&apos; * 10 + &apos;\n&apos;) f.close()if __name__ == &apos;__main__&apos;: jobstores = &#123; &apos;default&apos;: SQLAlchemyJobStore(url=&apos;sqlite:///jobs.sqlite&apos;) &#125; executors = &#123; &apos;default&apos;: ThreadPoolExecutor(20), &apos;processpool&apos;: ProcessPoolExecutor(5) &#125; job_defaults = &#123; &apos;coalesce&apos;: False, &apos;max_instances&apos;: 3 &#125; scheduler = BackgroundScheduler(jobstores=jobstores, executors=executors, job_defaults=job_defaults, timezone=&apos;Asia/Shanghai&apos;) #scheduler.add_job(tick, &apos;interval&apos;, seconds=3) scheduler.add_job(test,&apos;date&apos;,run_date=&apos;2018-05-18 17:12:01&apos;, args=[&apos;my_test5&apos;],id=&apos;my_test5&apos;) scheduler.start() #这里的调度任务是独立的一个线程 print(&apos;Press Ctrl+&#123;0&#125; to exit&apos;.format(&apos;Break&apos; if os.name == &apos;nt&apos; else &apos;C&apos;)) try: # This is here to simulate application activity (which keeps the main thread alive). while True: time.sleep(2) #其他任务是独立的线程执行 print(&apos;sleep!&apos;) except (KeyboardInterrupt, SystemExit): # Not strictly necessary if daemonic mode is enabled but should be done if possible scheduler.shutdown() print(&apos;Exit The Job!&apos;) 参考链接: https://www.cnblogs.com/hushaojun/p/5189109.htmlhttps://blog.csdn.net/blueheart20/article/details/70219490?locationNum=1&amp;fps=1](https://blog.csdn.net/blueheart20/article/details/70219490?locationNum=1&amp;fps=1)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>APScheduler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos显示tcp，udp的端口和进程等相关情况]]></title>
    <url>%2F2018%2F05%2F18%2Fcentos-tcp-udp-show%2F</url>
    <content type="text"><![CDATA[netstat命令netstat命令是一个监控TCP/IP网络的非常有用的工具，它可以显示路由表、实际的网络连接以及每一个网络接口设备netstat命令的功能是显示网络连接、路由表和网络接口信息，可以让用户得知目前都有哪些网络连接正在运作。该命令的一般格式为： 12345678910netstat [选项] 命令中各选项的含义如下： -a 显示所有socket，包括正在监听的。 -c 每隔1秒就重新显示一遍，直到用户中断它。 -i 显示所有网络接口的信息，格式同“ifconfig -e”。 -n 以网络IP地址代替名称，显示出网络连接情形。 -r 显示核心路由表，格式同“route -e”。 -t 显示TCP协议的连接情况。 -u 显示UDP协议的连接情况。 -v 显示正在进行的工作。 netstat -tunlp用于显示tcp，udp的端口和进程等相关情况1netstat -tunlp]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo文章属性冒号后面要加空格]]></title>
    <url>%2F2018%2F05%2F12%2Farticle-title%2F</url>
    <content type="text"><![CDATA[问题刚开始使用hexo，生成静态文件老是报错，错误提示如下：1can not read a block mapping entry; a multiline key may implicit key at line 解决办法冒号后面加空格 错误写法：12tags:[hexo入门]categories:hexo 正确写法:12tags: [hexo入门]categories: hexo]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
